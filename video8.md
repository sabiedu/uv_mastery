# M4V2: Migrating from `pip` to `uv`

## 1. Introduction

**(Talking Points)**

*   Welcome to the final video in our series on mastering `uv`! We've built new projects from scratch, but what about your existing projects? Most of us have projects currently using a `pip` and `requirements.txt` workflow.
*   In this video, we'll tackle one of the most important, real-world scenarios: migrating an existing `pip`-based project to `uv`.
*   We'll see how `uv` provides a smooth migration path, allowing you to adopt its powerful features without having to start over.

---

## 2. The Legacy Project

**(Talking Points)**

*   Let's imagine a typical legacy project. It probably has a `requirements.in` file for abstract dependencies and a `requirements.txt` file with the locked versions, generated by `pip-tools`.

*   **`requirements.in`:**
    ```
    # Abstract dependencies
    requests
    ```

*   **`requirements.txt`:** (Generated by `pip-compile`)
    ```
    #
    # This file is autogenerated by pip-compile
    #
    certifi==2024.2.2
        # via requests
    charset-normalizer==3.3.2
        # via requests
    idna==3.6
        # via requests
    requests==2.31.0
        # via -r requirements.in
    urllib3==2.2.1
        # via requests
    ```

*   Our goal is to move this project to a `pyproject.toml` and `uv.lock` workflow, without changing any of the currently installed package versions.

---

## 3. The Migration Process

**(Talking Points)**

*   The migration can be done in a few simple steps using `uv init` and `uv add`.

*   **Step 1: Initialize the `uv` project.**
    *   Run `uv init` in the project root. This creates the `pyproject.toml` file.

    ```bash
    uv init
    ```

*   **Step 2: Import dependencies while preserving locked versions.**
    *   This is the most critical step. We'll use `uv add` with two flags:
        *   `-r requirements.in`: to read the abstract dependencies.
        *   `-c requirements.txt`: to use the existing locked file as a *constraints* file.
    *   This tells `uv`: "add the dependencies from `requirements.in`, but when you resolve their versions, you *must* use the exact versions specified in `requirements.txt`."

    ```bash
    uv add -r requirements.in -c requirements.txt
    ```

*   `uv` will update `pyproject.toml` with `requests` and create a `uv.lock` file that respects the exact versions from your old `requirements.txt`. Your environment is now managed by `uv` but is identical to your old setup.

---

## 4. Handling Development Dependencies

**(Talking Points)**

*   What if you have a `requirements-dev.txt`? The process is the same, but we add the `--dev` flag.

*   **`requirements-dev.in`:**
    ```
    -r requirements.in
    pytest
    ```

*   **Migration command:**

    ```bash
    # First, migrate the base dependencies as before
    uv add -r requirements.in -c requirements.txt

    # Now, add the dev dependencies
    uv add -r requirements-dev.in -c requirements-dev.txt --dev
    ```

*   `uv` is smart enough to handle the `-r requirements.in` line and will add `pytest` to the `[tool.uv.dev-dependencies]` group in your `pyproject.toml`.

---

## 5. Cleaning Up and Moving Forward

**(Talking Points)**

*   Once the migration is complete and you've verified that `uv sync` creates the correct environment, you can safely delete your old `.in` and `.txt` files.

    ```bash
    rm requirements.in requirements.txt requirements-dev.in requirements-dev.txt
    ```

*   Your project is now fully migrated to `uv`! You can now use the modern, declarative workflow we've learned throughout this series.

---

## 6. Series Conclusion

**(Talking Points)**

*   And that brings us to the end of our series on mastering `uv`!
*   We've gone from the basics of installation to managing complex projects, building and publishing packages, and migrating legacy applications.
*   You are now fully equipped to use `uv` to make your Python development faster, cleaner, and more efficient.
*   Thank you for joining me on this journey. Happy coding!
